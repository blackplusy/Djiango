学生表Student: name age score_id成绩表
课程表 course: name teacher_id表
老师表teacher: name 课程表course_id
分数表socre:number student_id course_id
student score
主体:学生表 id 平均分 
1. 查询平均成绩大于60分的同学的id和平均成绩
Avg
 针对表的sql语句执行产生上面的效果
    select student_id,avg(number) from score group by student_id having avg(number)>60

两表建立关联，实际上django做了一件事
student       score
       id------>student_id
注意点:
	1、aggregate(Avg(score__number))全表聚合，让聚合函数有效,但不发生group by

	2、annotate(XXXX)---> group by student.pk  having XXXX
	相当于执行了group by student的主键， 求聚合函数Avg('score__number')


 Student.objects.all().annotate(avg=Avg(score__number)).filter(avg__gt=60).values('id','avg')
注意:
	1、凡是聚合的现象一定有聚合函数跟它一起作用
select count(*) from student group by gender
select max(number) from student;

2、2. 查询所有同学的id、姓名、选课的数量、总成绩
	聚合: Count   Sum
	聚合需要group by
	每个同学的id,姓名，选课数量，总成绩
	Student.objects.all().annotate
	语句:
	选课数量
		Count('score__course')
	总成绩:
		Sum('score__number')
	Student.objects.all.annotate(ct=Count('score__course'),sum=Sum('score__number')).values('id','name','ct','sum')
3、3. 查询姓“李”的老师的个数；
	Teacher.objects.filter(name__startswith='李').count()
4. 查询没学过“李老师”课的同学的id、姓名；
	Student.objects.all().exclude('score__course__teacher__name="李老师"').values('id','name')
5. 查询学过课程id为1和2的所有同学的id、姓名；
	Stuent.objects.all().filter(score__course__id=1,score__course__id=2).values('id','name')

		
